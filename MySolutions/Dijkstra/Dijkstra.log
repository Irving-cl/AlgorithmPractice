Dijkstra

解法一：
int L, X;
int [] array;              // Store one loop
int value = computeNValue( L, array );    // Compute value of n loops of array
if( value != -1 )          // Impossible to be divided into ijk pattern
    answer = false;
else
    answer = tryHeadToBeI( array, L ) && tryHeadToBeK( array, K );

结果：
1.对于样例，迅速产生正确结果；
2.对于small-practice.in，迅速产生正确结果；
3.对于large-practice.in，迅速产生正确结果；

编写过程：
    花了两天多的时间，今天才想出真正正确的算法，虽然还可能不是最简单。两天里也不乏有放弃的念头。这次我觉得伪代码都写不太清楚，也不知道这是好是坏。理解题意后会发现有个简单粗暴的办法――穷举，不过看到L和X的范围就知道这是绝对行不通的了。
    上次没做出来，看了其他选手的代码后，我觉得他们的思考方式是比较抽象的（有的难理解），却命中了事情的本质。我自然的想法是通过输入的特征来判定结果是true还是false，而一开始想得太复杂，根本无从下手，还多次返工。在昨天的时候，我想到了如果最终可以分为ijk的样子，那其全部乘起来就必然等于-1。这一点非常重要，不过还不足以解决问题，因为这是必要条件而不是充分条件。就在今天，我通过从头开始匹配I和从尾部开始匹配K最终得以解决问题。我想避免的就是庞大的数据量。而从头从尾开始匹配最多只需要四轮，因为四轮乘起来的结果为1，四轮都弄不出来最后也一定弄不出来。我觉得这个方法还是挺巧妙的，也挺流氓的，不过绝对正确。在实现的过程中也出了不少错，调了不久。
    这次还没有看其他选手的解法，说不定会和我一样呢。算法或许就是这样？解出来或许就是好的，也更是这些选手们追求的。

日期：2015.9.17